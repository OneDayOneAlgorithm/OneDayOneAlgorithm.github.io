---
layout: single
title:  "BOJ_1074"
categories: Algorithm
tags: BOJ
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 문제

![www.acmicpc.net_problem_1074.png](/images/2023-06-09-BOJ1074/1fefd39e09c211d13722f7b91e40fef355e8eeff.png)

## 풀이

1. N이 3이라 가정한다. N에서 1을 빼서 전체 보드를 4등분하고 N은 2가 된다..

2. 내가 찾는 좌표가 좌상단, 우상단, 좌하단, 우하단 중 어디 있는지 찾는다.

3. N을 3으로 가정해서 8*8 배열이고 최대 숫자가 64가 된다. 내가 찾는 좌표가 좌상단일 경우 숫자의 변화는 없다. 우상단일 경우 좌측에 존재하는 모든 숫자를 제거하고 16부터 시작하기에16을 ans에 더해준다. 좌하단일 경우 상단에 존재하는 모든 숫자를 제거하고 32부터 시작하기에 32를 ans에 더해준다. 우하단일 경우 좌측과 상단에 존재하는 모든 숫자를 제거하고 48부터 시작하기에 48을 ans에 더해준다.

4. 1,2,3이 한 세트이고 N이 0이 될 때까지 이를 계속 반복한다. 이후 최종값 ans을 출력한다.

```python
N,r,c = map(int,input().split())
ans = 0
while N != 0:
    N -= 1
    if r<2**N and c < 2**N:
        pass
    elif r<2**N and c >= 2**N:
        ans += (2**N)*(2**N)
        c -= (2**N)
    elif r>=2**N and c<2**N:
        ans += (2**N)*(2**N) * 2
        r -= (2**N)
    else:
        ans += (2**N)*(2**N) * 3
        c -= (2**N)
        r -= (2**N)
print(ans)
```


